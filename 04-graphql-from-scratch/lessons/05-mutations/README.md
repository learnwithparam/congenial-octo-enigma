# Mutations

Queries read data. Mutations change it. In a REST API, you express data changes through HTTP methods: POST to create, PUT/PATCH to update, DELETE to remove. In GraphQL, all data-changing operations go through the Mutation type. The client sends a mutation describing what to change, and the server returns the modified data.

In this lesson, we will implement five mutations for the LaunchPad API: creating startups, updating them, deleting them, upvoting, and adding comments. Along the way, we will learn mutation conventions, input types, and response patterns.

## What You'll Learn

- The difference between queries and mutations in GraphQL
- How to design mutation signatures with input types
- How to implement createStartup with proper data creation
- How to implement updateStartup with partial updates
- How to implement deleteStartup that returns a success indicator
- How to implement upvoteStartup as a toggle operation
- How to implement createComment for related data
- Mutation response patterns: returning the modified object
- How to test mutations in Apollo Sandbox

## Concepts

### Mutations vs Queries

In the GraphQL spec, the only difference between queries and mutations is execution order. Query fields execute in parallel, while mutation fields execute in sequence. This matters when you send multiple mutations in one request:

```graphql
mutation {
  first: createStartup(input: { ... }) { id }
  second: createStartup(input: { ... }) { id }
}
```

The `first` mutation finishes before `second` starts. This guarantees that side effects (like incrementing counters or sending emails) happen in a predictable order.

By convention, mutations:

- Live under the `Mutation` type, not `Query`
- Have verb-based names: `createStartup`, `updateStartup`, `deleteStartup` (not `startup` or `newStartup`)
- Accept their data through input types rather than many individual arguments
- Return the modified object so the client can update its cache without a separate query

### Input Types for Mutations

We already defined our input types in the schema lesson:

```graphql
input CreateStartupInput {
  name: String!
  tagline: String!
  description: String!
  url: String!
  categoryId: ID!
  founderId: ID!
}

input UpdateStartupInput {
  name: String
  tagline: String
  description: String
  url: String
  categoryId: ID
}
```

Notice the pattern:

- `CreateStartupInput` has all required fields (with `!`). You cannot create a startup without providing every field.
- `UpdateStartupInput` has all optional fields (without `!`). You only send the fields you want to change. This enables partial updates -- changing just the tagline without re-sending the entire startup.
- Neither input type includes `id` (generated by the server), `upvotes` (managed by the upvoteStartup mutation), or `createdAt` (set automatically).
- The `founderId` is in CreateStartupInput but not UpdateStartupInput, because you cannot change the founder of a startup after creation.

### Mutation Response Patterns

There are several common patterns for what mutations return:

Pattern 1: Return the modified object. This is the most common and most useful pattern. After creating or updating a startup, return the full Startup type. The client can select exactly the fields it needs to update its UI:

```graphql
mutation {
  createStartup(input: { ... }) {
    id
    name
    slug
    createdAt
  }
}
```

Pattern 2: Return a boolean. Simple for delete operations where the object no longer exists:

```graphql
mutation {
  deleteStartup(id: "1")
}
```

Pattern 3: Return a payload type with metadata. For complex operations, you might return a wrapper type:

```graphql
type CreateStartupPayload {
  startup: Startup!
  success: Boolean!
  message: String
}
```

We will use Pattern 1 for most mutations and Pattern 2 for delete. Pattern 3 is common in larger APIs but adds complexity we do not need yet.

## Step by Step

### Step 1: Add Utility Functions for Data Manipulation

Since we are using in-memory arrays, we need helper functions to generate IDs and create slugs. Add these to `src/data.ts`:

```typescript
// Add to the bottom of src/data.ts

let nextStartupId = 7;
let nextCommentId = 9;

export function generateStartupId(): string {
  return String(nextStartupId++);
}

export function generateCommentId(): string {
  return String(nextCommentId++);
}

export function createSlug(name: string): string {
  return name
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-|-$/g, '');
}
```

The `nextStartupId` starts at 7 because we already have 6 startups. The `nextCommentId` starts at 9 because we have 8 comments. In a real application, the database would generate IDs.

The `createSlug` function converts a name like "My New Startup" into "my-new-startup" by lowercasing, replacing non-alphanumeric characters with hyphens, and trimming leading/trailing hyphens.

### Step 2: Define Mutation Argument Types

Add the mutation argument types to `src/types.ts`:

```typescript
// src/types.ts

export interface StartupsArgs {
  limit?: number;
  offset?: number;
  categoryId?: string;
  search?: string;
  sortBy?: 'NEWEST' | 'OLDEST' | 'UPVOTES_DESC' | 'UPVOTES_ASC' | 'NAME_ASC' | 'NAME_DESC';
}

export interface StartupCountArgs {
  categoryId?: string;
  search?: string;
}

export interface CreateStartupInput {
  name: string;
  tagline: string;
  description: string;
  url: string;
  categoryId: string;
  founderId: string;
}

export interface UpdateStartupInput {
  name?: string;
  tagline?: string;
  description?: string;
  url?: string;
  categoryId?: string;
}

export interface CreateStartupArgs {
  input: CreateStartupInput;
}

export interface UpdateStartupArgs {
  id: string;
  input: UpdateStartupInput;
}

export interface CreateCommentArgs {
  startupId: string;
  content: string;
  authorId: string;
}
```

Notice how we separate the `input` object from the top-level args. When a mutation is defined as `createStartup(input: CreateStartupInput!)`, the resolver receives `args.input` as the nested object.

### Step 3: Implement createStartup

Now let's implement the mutations. Update `src/resolvers.ts` -- we will replace the placeholder Mutation resolvers one by one.

First, update the imports:

```typescript
// src/resolvers.ts

import {
  startups,
  users,
  categories,
  comments,
  generateStartupId,
  generateCommentId,
  createSlug,
} from './data.js';
import type { StartupRecord, UserRecord, CategoryRecord, CommentRecord } from './data.js';
import type {
  StartupsArgs,
  StartupCountArgs,
  CreateStartupArgs,
  UpdateStartupArgs,
  CreateCommentArgs,
} from './types.js';
```

Now implement the `createStartup` mutation:

```typescript
Mutation: {
  createStartup: (_parent: unknown, args: CreateStartupArgs) => {
    const { input } = args;

    // Verify the founder exists
    const founder = users.find((u) => u.id === input.founderId);
    if (!founder) {
      throw new Error('Founder not found with id: ' + input.founderId);
    }

    // Verify the category exists
    const category = categories.find((c) => c.id === input.categoryId);
    if (!category) {
      throw new Error('Category not found with id: ' + input.categoryId);
    }

    // Create the new startup record
    const newStartup: StartupRecord = {
      id: generateStartupId(),
      name: input.name,
      slug: createSlug(input.name),
      tagline: input.tagline,
      description: input.description,
      url: input.url,
      upvotes: 0,
      categoryId: input.categoryId,
      founderId: input.founderId,
      createdAt: new Date().toISOString(),
    };

    // Add to the data store
    startups.push(newStartup);

    return newStartup;
  },
```

Let's walk through this resolver:

We destructure `args.input` to get the input fields. This matches the SDL where the mutation argument is `input: CreateStartupInput!`.

We validate that the referenced founder and category exist. If not, we throw an error. In a later lesson, we will implement more structured error handling, but throwing is fine for now. Apollo Server catches thrown errors and returns them in the response's `errors` array.

We construct a new `StartupRecord` with a generated ID, a slug derived from the name, zero upvotes, and the current timestamp.

We push the new record into the in-memory array. In a real app, this would be a database INSERT.

We return the new startup record. Because our type resolvers (Startup.founder, Startup.category, etc.) are already set up, the client can query any related fields on the returned startup.

### Step 4: Implement updateStartup

```typescript
  updateStartup: (_parent: unknown, args: UpdateStartupArgs) => {
    const index = startups.findIndex((s) => s.id === args.id);
    if (index === -1) {
      return null;
    }

    const existing = startups[index];
    const { input } = args;

    // Apply partial updates -- only update fields that were provided
    const updated: StartupRecord = {
      ...existing,
      name: input.name ?? existing.name,
      tagline: input.tagline ?? existing.tagline,
      description: input.description ?? existing.description,
      url: input.url ?? existing.url,
      categoryId: input.categoryId ?? existing.categoryId,
    };

    // Update the slug if the name changed
    if (input.name && input.name !== existing.name) {
      updated.slug = createSlug(input.name);
    }

    // Verify the new category exists if it was changed
    if (input.categoryId) {
      const category = categories.find((c) => c.id === input.categoryId);
      if (!category) {
        throw new Error('Category not found with id: ' + input.categoryId);
      }
    }

    // Replace the record in the data store
    startups[index] = updated;

    return updated;
  },
```

Key points about the update resolver:

We return null if the startup is not found. The schema defines `updateStartup` as returning `Startup` (nullable), so null indicates "not found" to the client.

We use the nullish coalescing operator (`??`) to implement partial updates. If `input.name` is undefined (not provided by the client), we keep the existing name. If it is provided, we use the new value.

We automatically regenerate the slug when the name changes. This keeps the slug in sync.

We validate the new category ID if one was provided. You do not want to set a startup's category to an ID that does not exist.

### Step 5: Implement deleteStartup

```typescript
  deleteStartup: (_parent: unknown, args: { id: string }) => {
    const index = startups.findIndex((s) => s.id === args.id);
    if (index === -1) {
      return false;
    }

    // Remove the startup
    startups.splice(index, 1);

    // Also remove associated comments
    for (let i = comments.length - 1; i >= 0; i--) {
      if (comments[i].startupId === args.id) {
        comments.splice(i, 1);
      }
    }

    return true;
  },
```

The delete resolver returns `Boolean!` -- true if the startup was found and deleted, false if it was not found.

We also clean up associated comments. In a real database, you would use cascading deletes or foreign key constraints. With in-memory arrays, we iterate backward through the comments array (to avoid index shifting issues when splicing) and remove any comment that references the deleted startup.

### Step 6: Implement upvoteStartup

```typescript
  upvoteStartup: (_parent: unknown, args: { id: string }) => {
    const startup = startups.find((s) => s.id === args.id);
    if (!startup) {
      return null;
    }

    startup.upvotes += 1;

    return startup;
  },
```

This is a simple increment operation. In a real application, you would track which users have upvoted to prevent duplicates and enable toggling. For now, each call increments the count by 1.

The resolver returns the updated startup, so the client can immediately update the displayed upvote count:

```graphql
mutation {
  upvoteStartup(id: "1") {
    id
    upvotes
  }
}
```

### Step 7: Implement createComment

```typescript
  createComment: (_parent: unknown, args: CreateCommentArgs) => {
    // Verify the startup exists
    const startup = startups.find((s) => s.id === args.startupId);
    if (!startup) {
      throw new Error('Startup not found with id: ' + args.startupId);
    }

    // Verify the author exists
    const author = users.find((u) => u.id === args.authorId);
    if (!author) {
      throw new Error('User not found with id: ' + args.authorId);
    }

    const newComment: CommentRecord = {
      id: generateCommentId(),
      content: args.content,
      startupId: args.startupId,
      authorId: args.authorId,
      createdAt: new Date().toISOString(),
    };

    comments.push(newComment);

    return newComment;
  },
```

The createComment mutation takes individual arguments (`startupId`, `content`, `authorId`) rather than an input type. This is because there are only three fields, and they are all required. Using individual arguments keeps the mutation call concise:

```graphql
mutation {
  createComment(startupId: "1", content: "Great product!", authorId: "2") {
    id
    content
    author {
      name
    }
  }
}
```

We validate that both the startup and the author exist before creating the comment. If either is missing, we throw an error.

### Step 8: The Complete Resolvers File

Here is the complete `src/resolvers.ts` with all mutations implemented:

```typescript
// src/resolvers.ts

import {
  startups,
  users,
  categories,
  comments,
  generateStartupId,
  generateCommentId,
  createSlug,
} from './data.js';
import type { StartupRecord, UserRecord, CategoryRecord, CommentRecord } from './data.js';
import type {
  StartupsArgs,
  StartupCountArgs,
  CreateStartupArgs,
  UpdateStartupArgs,
  CreateCommentArgs,
} from './types.js';

function filterStartups(
  items: StartupRecord[],
  categoryId?: string,
  search?: string
): StartupRecord[] {
  let result = items;

  if (categoryId) {
    result = result.filter((s) => s.categoryId === categoryId);
  }

  if (search) {
    const term = search.toLowerCase();
    result = result.filter(
      (s) =>
        s.name.toLowerCase().includes(term) ||
        s.tagline.toLowerCase().includes(term)
    );
  }

  return result;
}

function sortStartups(
  items: StartupRecord[],
  sortBy?: string
): StartupRecord[] {
  const sorted = [...items];

  switch (sortBy) {
    case 'NEWEST':
      return sorted.sort(
        (a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
      );
    case 'OLDEST':
      return sorted.sort(
        (a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()
      );
    case 'UPVOTES_DESC':
      return sorted.sort((a, b) => b.upvotes - a.upvotes);
    case 'UPVOTES_ASC':
      return sorted.sort((a, b) => a.upvotes - b.upvotes);
    case 'NAME_ASC':
      return sorted.sort((a, b) => a.name.localeCompare(b.name));
    case 'NAME_DESC':
      return sorted.sort((a, b) => b.name.localeCompare(a.name));
    default:
      return sorted.sort(
        (a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
      );
  }
}

export const resolvers = {
  Query: {
    startups: (_parent: unknown, args: StartupsArgs) => {
      let result = filterStartups(startups, args.categoryId, args.search);
      result = sortStartups(result, args.sortBy);

      const offset = args.offset ?? 0;
      if (args.limit !== undefined) {
        result = result.slice(offset, offset + args.limit);
      } else if (offset > 0) {
        result = result.slice(offset);
      }

      return result;
    },

    startup: (_parent: unknown, args: { id: string }) => {
      return startups.find((s) => s.id === args.id) || null;
    },

    startupCount: (_parent: unknown, args: StartupCountArgs) => {
      const filtered = filterStartups(startups, args.categoryId, args.search);
      return filtered.length;
    },

    categories: () => {
      return categories;
    },

    category: (_parent: unknown, args: { id: string }) => {
      return categories.find((c) => c.id === args.id) || null;
    },

    user: (_parent: unknown, args: { id: string }) => {
      return users.find((u) => u.id === args.id) || null;
    },
  },

  Startup: {
    founder: (parent: StartupRecord) => {
      return users.find((u) => u.id === parent.founderId);
    },

    category: (parent: StartupRecord) => {
      return categories.find((c) => c.id === parent.categoryId);
    },

    comments: (parent: StartupRecord) => {
      return comments.filter((c) => c.startupId === parent.id);
    },
  },

  User: {
    startups: (parent: UserRecord) => {
      return startups.filter((s) => s.founderId === parent.id);
    },
  },

  Category: {
    startups: (parent: CategoryRecord) => {
      return startups.filter((s) => s.categoryId === parent.id);
    },
  },

  Comment: {
    author: (parent: CommentRecord) => {
      return users.find((u) => u.id === parent.authorId);
    },

    startup: (parent: CommentRecord) => {
      return startups.find((s) => s.id === parent.startupId);
    },
  },

  Mutation: {
    createStartup: (_parent: unknown, args: CreateStartupArgs) => {
      const { input } = args;

      const founder = users.find((u) => u.id === input.founderId);
      if (!founder) {
        throw new Error('Founder not found with id: ' + input.founderId);
      }

      const category = categories.find((c) => c.id === input.categoryId);
      if (!category) {
        throw new Error('Category not found with id: ' + input.categoryId);
      }

      const newStartup: StartupRecord = {
        id: generateStartupId(),
        name: input.name,
        slug: createSlug(input.name),
        tagline: input.tagline,
        description: input.description,
        url: input.url,
        upvotes: 0,
        categoryId: input.categoryId,
        founderId: input.founderId,
        createdAt: new Date().toISOString(),
      };

      startups.push(newStartup);

      return newStartup;
    },

    updateStartup: (_parent: unknown, args: UpdateStartupArgs) => {
      const index = startups.findIndex((s) => s.id === args.id);
      if (index === -1) {
        return null;
      }

      const existing = startups[index];
      const { input } = args;

      const updated: StartupRecord = {
        ...existing,
        name: input.name ?? existing.name,
        tagline: input.tagline ?? existing.tagline,
        description: input.description ?? existing.description,
        url: input.url ?? existing.url,
        categoryId: input.categoryId ?? existing.categoryId,
      };

      if (input.name && input.name !== existing.name) {
        updated.slug = createSlug(input.name);
      }

      if (input.categoryId) {
        const category = categories.find((c) => c.id === input.categoryId);
        if (!category) {
          throw new Error('Category not found with id: ' + input.categoryId);
        }
      }

      startups[index] = updated;

      return updated;
    },

    deleteStartup: (_parent: unknown, args: { id: string }) => {
      const index = startups.findIndex((s) => s.id === args.id);
      if (index === -1) {
        return false;
      }

      startups.splice(index, 1);

      for (let i = comments.length - 1; i >= 0; i--) {
        if (comments[i].startupId === args.id) {
          comments.splice(i, 1);
        }
      }

      return true;
    },

    upvoteStartup: (_parent: unknown, args: { id: string }) => {
      const startup = startups.find((s) => s.id === args.id);
      if (!startup) {
        return null;
      }

      startup.upvotes += 1;

      return startup;
    },

    createComment: (_parent: unknown, args: CreateCommentArgs) => {
      const startup = startups.find((s) => s.id === args.startupId);
      if (!startup) {
        throw new Error('Startup not found with id: ' + args.startupId);
      }

      const author = users.find((u) => u.id === args.authorId);
      if (!author) {
        throw new Error('User not found with id: ' + args.authorId);
      }

      const newComment: CommentRecord = {
        id: generateCommentId(),
        content: args.content,
        startupId: args.startupId,
        authorId: args.authorId,
        createdAt: new Date().toISOString(),
      };

      comments.push(newComment);

      return newComment;
    },
  },
};
```

### Step 9: Test createStartup

Start the server and open Apollo Sandbox. Run this mutation:

```graphql
mutation CreateStartup {
  createStartup(
    input: {
      name: "DataPipe"
      tagline: "ETL pipelines in 5 minutes"
      description: "DataPipe lets you build, test, and deploy data pipelines with a visual editor. Connect any source to any destination."
      url: "https://datapipe.dev"
      categoryId: "2"
      founderId: "3"
    }
  ) {
    id
    name
    slug
    tagline
    upvotes
    createdAt
    founder {
      name
    }
    category {
      name
    }
  }
}
```

The response should include the new startup with:
- A generated ID ("7")
- The slug "datapipe" (auto-generated from the name)
- 0 upvotes (new startups start with 0)
- The current timestamp for createdAt
- The founder resolved to "Jordan Lee" (user 3)
- The category resolved to "Developer Tools" (category 2)

Now verify it appears in the list:

```graphql
query {
  startups {
    name
  }
  startupCount
}
```

You should see 7 startups, including the new DataPipe entry.

### Step 10: Test createStartup With Variables

Using the Variables panel:

```graphql
mutation CreateWithVars($input: CreateStartupInput!) {
  createStartup(input: $input) {
    id
    name
    slug
    founder {
      name
    }
  }
}
```

Variables:

```json
{
  "input": {
    "name": "CloudSync Pro",
    "tagline": "Sync anything to any cloud",
    "description": "CloudSync Pro provides a unified API for syncing files, databases, and configurations across AWS, GCP, and Azure.",
    "url": "https://cloudsync.pro",
    "categoryId": "2",
    "founderId": "1"
  }
}
```

### Step 11: Test updateStartup

Update just the tagline of startup "1":

```graphql
mutation UpdateTagline {
  updateStartup(id: "1", input: { tagline: "The smartest AI coding assistant" }) {
    id
    name
    tagline
    slug
  }
}
```

The name and slug should remain unchanged. Only the tagline updates.

Now update the name, which should also update the slug:

```graphql
mutation UpdateName {
  updateStartup(id: "1", input: { name: "CodeBuddy Pro" }) {
    id
    name
    slug
    tagline
  }
}
```

The slug should change from "codebuddy-ai" to "codebuddy-pro".

Test updating a non-existent startup:

```graphql
mutation UpdateNotFound {
  updateStartup(id: "999", input: { name: "Ghost" }) {
    id
    name
  }
}
```

This should return `null` for the entire mutation result.

### Step 12: Test deleteStartup

First, check the comments for startup "2":

```graphql
query BeforeDelete {
  startup(id: "2") {
    name
    comments {
      id
      content
    }
  }
}
```

You should see DeployBot with 2 comments. Now delete it:

```graphql
mutation DeleteStartup {
  deleteStartup(id: "2")
}
```

Returns `true`. Verify it is gone:

```graphql
query AfterDelete {
  startup(id: "2") {
    name
  }
  startupCount
}
```

The startup query returns null and the count decreased by 1. The comments for startup "2" were also removed.

Delete a non-existent startup:

```graphql
mutation DeleteNotFound {
  deleteStartup(id: "999")
}
```

Returns `false`.

### Step 13: Test upvoteStartup

Check the current upvote count:

```graphql
query CheckUpvotes {
  startup(id: "3") {
    name
    upvotes
  }
}
```

FinTrack has 175 upvotes. Upvote it:

```graphql
mutation Upvote {
  upvoteStartup(id: "3") {
    name
    upvotes
  }
}
```

Returns 176. Run it again -- returns 177. Each call increments by 1.

### Step 14: Test createComment

Add a comment to startup "4" (MedNote):

```graphql
mutation AddComment {
  createComment(
    startupId: "4"
    content: "This could revolutionize healthcare documentation."
    authorId: "1"
  ) {
    id
    content
    createdAt
    author {
      name
    }
    startup {
      name
    }
  }
}
```

The response includes the new comment with author (Sarah Chen) and startup (MedNote) resolved through type resolvers.

Verify it appears in the startup's comments:

```graphql
query VerifyComment {
  startup(id: "4") {
    name
    comments {
      content
      author {
        name
      }
    }
  }
}
```

You should see the original 2 comments plus your new one.

### Step 15: Test Error Cases

Try creating a startup with an invalid founder ID:

```graphql
mutation BadFounder {
  createStartup(
    input: {
      name: "Ghost Startup"
      tagline: "This should fail"
      description: "Testing error handling"
      url: "https://ghost.dev"
      categoryId: "1"
      founderId: "999"
    }
  ) {
    id
  }
}
```

The response includes an `errors` array:

```json
{
  "errors": [
    {
      "message": "Founder not found with id: 999",
      "locations": [{ "line": 2, "column": 3 }],
      "path": ["createStartup"]
    }
  ],
  "data": null
}
```

The `data` field is null because the mutation threw an error. The `errors` array contains the error message, the location in the query where it occurred, and the path to the field that failed.

Try creating a comment for a non-existent startup:

```graphql
mutation BadStartup {
  createComment(startupId: "999", content: "Hello", authorId: "1") {
    id
  }
}
```

Same pattern: errors array with a descriptive message, null data.

## Understanding Mutation Execution

When a mutation returns an object type, the type resolvers run exactly as they do for queries. Consider this:

```graphql
mutation {
  createStartup(input: { ... }) {
    id
    name
    founder {
      name
      startups {
        name
      }
    }
    comments {
      content
    }
  }
}
```

After `createStartup` returns the new StartupRecord:

1. `id` and `name` resolve via default resolvers
2. `Startup.founder` resolver runs, finds the User by founderId
3. `User.startups` resolver runs, finds all startups by that founder (including the new one)
4. `Startup.comments` resolver runs, returns comments for the new startup (empty list since it was just created)

The resolver chain is identical for queries and mutations. The only difference is where the chain starts: `Query.startup` vs `Mutation.createStartup`.

## A Note on Data Persistence

Since we are using in-memory arrays, all changes are lost when the server restarts. Create a startup, restart the server, and it is gone. This is perfectly fine for learning and development. In a production application, you would:

- Use a database (PostgreSQL, MongoDB, etc.) as the data store
- Replace array operations with database queries
- Handle transactions for operations that modify multiple tables (like deleteStartup removing both the startup and its comments)

The resolver structure stays the same. Only the data access layer changes.

## Try It Yourself

Exercise 1: Create a new startup, then immediately update its tagline in a second mutation. Verify both changes by querying the startup.

Exercise 2: Implement a "downvote" by modifying the upvoteStartup mutation to accept a second argument `direction` (an enum of UP or DOWN). Update the schema, the types, and the resolver.

Exercise 3: Create a startup, add 3 comments to it, then delete the startup. Verify the comments were cleaned up by trying to list all comments (you would need to add a `comments` query to the Query type).

Exercise 4: Try sending two mutations in a single request using aliases. Create two startups in one request and verify they both get unique IDs:

```graphql
mutation CreateTwo {
  first: createStartup(input: { ... }) { id name }
  second: createStartup(input: { ... }) { id name }
}
```

Exercise 5: Think about what would happen if a mutation partially fails in a multi-mutation request. For example, the first createStartup succeeds but the second throws an error. Does the first startup still exist? (Hint: yes, GraphQL does not have built-in transaction support across multiple root mutations.)

## Key Takeaways

- Mutations are GraphQL's mechanism for data changes. They execute sequentially (unlike queries, which can execute in parallel).
- Use input types (CreateStartupInput, UpdateStartupInput) to group mutation arguments. Required fields get `!` in create inputs; all fields are optional in update inputs for partial updates.
- Return the modified object from mutations so clients can update their UI without a separate query.
- Always validate referenced entities (foreign keys) before creating or updating records.
- Delete mutations should clean up associated data (comments, in our case) and return a boolean success indicator.
- Error handling in mutations follows the same pattern as queries: thrown errors appear in the response's `errors` array.
- The resolver chain for mutations is identical to queries -- type resolvers run the same way regardless of whether the root operation is a Query or Mutation.

## Next Steps

Our mutations work, but they accept any input without validation. What if someone creates a startup with an empty name? Or a URL that is not valid? In the next lesson, we will use Zod to add robust input validation to our mutations, returning clear error messages that help clients fix their input.
