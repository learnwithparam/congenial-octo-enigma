# 03 â€” Extracting the Auth Service

The auth service is the first piece we extract from the monolith. It is the ideal candidate because it has a clear boundary (user identity), a small API surface (five endpoints), and minimal dependencies (Redis for health checks, no outbound calls to other services). In this lesson, we walk through the complete auth-service implementation, examining how it handles registration, login, token management, and independent deployment.

## What You'll Learn

- How to structure a standalone Express microservice with its own entry point and configuration
- How token-based authentication works with registration, login, and verification endpoints
- How to design an API that other services can consume for token verification
- How independent deployment works through isolated Dockerfiles and port configuration

## Key Concepts

### Service Configuration

Every microservice in our architecture starts with a configuration object that defines its identity. The auth-service declares itself using the shared ServiceConfig interface:

```ts
import type { User, ServiceConfig } from "../../shared/types.js";

const config: ServiceConfig = {
  name: "auth-service",
  port: parseInt(process.env.AUTH_PORT || "3001", 10),
  version: "1.0.0",
};
```

The port is configurable through the AUTH_PORT environment variable, defaulting to 3001. This is essential for microservices: each service runs on its own port, and the gateway knows how to find each one. The version field will appear in health check responses, making it easy to verify which version is running in each environment.

The ServiceConfig interface in shared/types.ts ensures consistency across all services:

```ts
export interface ServiceConfig {
  name: string;
  port: number;
  version: string;
}
```

### The Express Application Setup

The auth-service creates its own Express application, completely independent from the gateway or any other service:

```ts
const app = express();

// --- Middleware ---
app.use(express.json());
app.use(correlationId);
app.use(requestLogger(logger));
```

Three pieces of middleware are applied in order. First, express.json() parses incoming JSON request bodies. Second, the correlationId middleware either extracts an existing correlation ID from the x-correlation-id header (forwarded by the gateway) or generates a new one. Third, the requestLogger middleware logs every request with timing information.

This middleware stack is identical across all our services. The shared middleware in shared/middleware/ ensures that every service handles correlation IDs and logging the same way without duplicating code.

### User Registration

The registration endpoint creates a new user account and returns a session token:

```ts
app.post("/auth/register", (req, res) => {
  const { email, name, password } = req.body;

  if (!email || !name || !password) {
    res.status(400).json({ error: "email, name, and password are required" });
    return;
  }

  const existing = Array.from(users.values()).find((u) => u.email === email);
  if (existing) {
    res.status(409).json({ error: "User already exists" });
    return;
  }

  const user: User & { password: string } = {
    id: crypto.randomUUID(),
    email,
    name,
    password, // In production, hash this!
    createdAt: new Date().toISOString(),
  };

  users.set(user.id, user);
  logger.info({ userId: user.id, email }, "User registered");

  const token = crypto.randomUUID();
  sessions.set(token, user.id);

  res.status(201).json({
    user: { id: user.id, email: user.email, name: user.name },
    token,
  });
});
```

Several design decisions are worth noting here.

Input validation happens immediately. If any required field is missing, the endpoint returns 400 before doing any work. This early-return pattern keeps the happy path clean.

Uniqueness checking uses the email field. In a production system, this would be a database unique constraint. In our workshop, the in-memory Map serves the same purpose.

The user ID is generated using crypto.randomUUID(), which produces a cryptographically random UUID v4. This is important because IDs generated by the service should not be guessable.

The password is stored in plaintext in this workshop implementation. The comment "In production, hash this!" is intentional. In a real system, you would use bcrypt or argon2:

```ts
// Production password hashing example
import bcrypt from "bcrypt";

const saltRounds = 12;
const hashedPassword = await bcrypt.hash(password, saltRounds);

// Store hashedPassword instead of password
// On login, verify with:
const isValid = await bcrypt.compare(password, user.hashedPassword);
```

The response deliberately excludes the password field. The returned user object only contains id, email, and name. Never send passwords or hashes back to the client.

### User Login

The login endpoint authenticates an existing user and creates a new session:

```ts
app.post("/auth/login", (req, res) => {
  const { email, password } = req.body;

  const user = Array.from(users.values()).find(
    (u) => u.email === email && u.password === password
  );

  if (!user) {
    res.status(401).json({ error: "Invalid credentials" });
    return;
  }

  const token = crypto.randomUUID();
  sessions.set(token, user.id);

  logger.info({ userId: user.id }, "User logged in");

  res.json({
    user: { id: user.id, email: user.email, name: user.name },
    token,
  });
});
```

The response for invalid email and invalid password is identical: "Invalid credentials." This is a security best practice. If you return "User not found" for a bad email and "Wrong password" for a bad password, an attacker can enumerate which email addresses are registered in your system.

Each successful login creates a new token. A user can have multiple active sessions (logging in from different devices), and each session has its own token.

### Token Verification

The verify endpoint is the most important for microservice communication. Other services call this endpoint to confirm that a request is authenticated:

```ts
app.get("/auth/verify", (req, res) => {
  const authHeader = req.headers.authorization;
  if (!authHeader?.startsWith("Bearer ")) {
    res.status(401).json({ error: "Missing or invalid token" });
    return;
  }

  const token = authHeader.slice(7);
  const userId = sessions.get(token);

  if (!userId) {
    res.status(401).json({ error: "Invalid token" });
    return;
  }

  const user = users.get(userId);
  if (!user) {
    res.status(401).json({ error: "User not found" });
    return;
  }

  res.json({ userId: user.id, email: user.email });
});
```

This endpoint follows the Bearer token pattern from the OAuth specification. The client sends an Authorization header with the value "Bearer {token}". The service extracts the token, looks up the session, and returns the associated user's ID and email.

This is how services communicate about authentication without sharing databases. The notification-service does not need to know about the sessions Map. It can simply call GET /auth/verify with the user's token and trust the response.

In production, you would likely replace the in-memory session store with JWT (JSON Web Tokens). JWTs are self-contained: the token itself carries the user information, signed by the auth service's private key. Other services verify the signature without calling the auth service at all, reducing latency and removing a synchronous dependency.

### User Profile and Logout

The profile endpoint returns the current user's data, and logout destroys the session:

```ts
app.get("/auth/me", (req, res) => {
  const authHeader = req.headers.authorization;
  if (!authHeader?.startsWith("Bearer ")) {
    res.status(401).json({ error: "Missing or invalid token" });
    return;
  }

  const token = authHeader.slice(7);
  const userId = sessions.get(token);

  if (!userId) {
    res.status(401).json({ error: "Invalid token" });
    return;
  }

  const user = users.get(userId);
  if (!user) {
    res.status(401).json({ error: "User not found" });
    return;
  }

  res.json({ id: user.id, email: user.email, name: user.name });
});

app.post("/auth/logout", (req, res) => {
  const authHeader = req.headers.authorization;
  if (authHeader?.startsWith("Bearer ")) {
    const token = authHeader.slice(7);
    sessions.delete(token);
  }

  res.json({ message: "Logged out" });
});
```

The logout endpoint always returns success, even if no valid token was provided. This is intentional: logout is an idempotent operation. If the token is already invalid or missing, the user is effectively already logged out.

### Data Storage

The auth-service uses in-memory Maps for both users and sessions:

```ts
const users = new Map<string, User & { password: string }>();
const sessions = new Map<string, string>(); // token -> userId
```

This is a workshop simplification. In production, you would use a database (PostgreSQL, MongoDB) for users and Redis for sessions. The important architectural point is that this data belongs exclusively to the auth-service. No other service reads or writes to these stores.

### Health Checks

The auth-service registers a health check that includes Redis as a dependency:

```ts
const redis = getRedis();

app.use(
  createHealthRouter(config, [
    { name: "redis", check: redisHealthCheck(redis) },
  ])
);
```

Even though the workshop uses in-memory storage, the Redis connection is still used for health check verification and could be used for session storage in production. The health endpoint reports whether Redis is reachable, giving operators visibility into dependency health.

### Graceful Shutdown

The auth-service handles SIGTERM and SIGINT signals for clean shutdown:

```ts
async function shutdown(signal: string) {
  logger.info({ signal }, "Shutting down auth service");
  server.close();
  await closeRedis();
  process.exit(0);
}

process.on("SIGTERM", () => shutdown("SIGTERM"));
process.on("SIGINT", () => shutdown("SIGINT"));
```

This is critical for containerized deployments. When Kubernetes or Docker sends SIGTERM, the service stops accepting new connections (server.close()), closes the Redis connection cleanly (await closeRedis()), and exits. Without this, active connections would be dropped and Redis connections would leak.

### Independent Deployment

The auth-service has its own Dockerfile:

```dockerfile
FROM node:20-alpine
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY shared/ ./shared/
COPY auth-service/ ./auth-service/
COPY tsconfig.json ./
EXPOSE 3001
CMD ["npx", "tsx", "auth-service/src/index.ts"]
```

This Dockerfile copies only the shared/ directory and the auth-service/ directory. It does not include gateway/ or notification-service/. A change to notification-service code does not require rebuilding the auth container. This is deploy independence in action.

## Step by Step

### Step 1: Create the Service Entry Point

Start with the minimal Express app, configuration, and middleware:

```ts
import express from "express";
const app = express();
app.use(express.json());
```

### Step 2: Add Shared Middleware

Apply correlation ID tracking and request logging from the shared library. This ensures your service participates in the distributed tracing infrastructure from day one.

### Step 3: Implement the Core Routes

Build the five endpoints in order: register, login, verify, me, logout. Start with register and login since they create the data that verify and me depend on.

### Step 4: Add Health Checks

Wire up the health router with any dependencies (Redis, database). The /health endpoint should be available before the service is registered with the gateway.

### Step 5: Add Graceful Shutdown

Handle SIGTERM and SIGINT to close the HTTP server and any connections. Test this locally by pressing Ctrl+C and verifying that the shutdown log message appears.

### Step 6: Create the Dockerfile

Build a container image that includes only the files this service needs. Test it with docker build and docker run to verify it starts independently.

## Exercise

Extend the auth-service with the following features:

1. Add a password hashing layer. Install bcrypt and modify the register endpoint to hash passwords before storing them. Modify the login endpoint to use bcrypt.compare instead of direct string comparison.

2. Add a token expiration mechanism. When creating a session, store a timestamp. In the verify endpoint, check whether the token is older than 1 hour. If so, return 401 with "Token expired."

3. Add a PUT /auth/me endpoint that allows users to update their name. Verify the token first, then update the user record.

4. Add input validation for the email field. Reject registration attempts where the email does not match a basic email regex pattern.

5. Write a test that registers a user, logs in, verifies the token, and logs out. Use the exported app object with a testing library like supertest.

## Summary

The auth-service demonstrates the anatomy of a well-extracted microservice. It has a focused responsibility (user identity), a small API surface (five endpoints), and owns its own data (users and sessions). It participates in the shared infrastructure (correlation IDs, structured logging, health checks) without depending on any other business service.

The key architectural patterns at work are: token-based authentication with the Bearer pattern, idempotent operations (logout always succeeds), security-conscious responses (same error for wrong email and wrong password), and graceful shutdown for container deployments.

In the next lesson, we extract the notification service, which introduces asynchronous processing with BullMQ and a fundamentally different communication pattern.
